<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>EmoPlay.play API documentation</title>
<meta name="description" content="Module Play" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>EmoPlay.play</code></h1>
</header>
<section id="section-intro">
<p>Module Play</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Module Play
&#34;&#34;&#34;

import re
import pandas as pd
from bs4 import BeautifulSoup

# Custom classes
import character
import speech

class Play:
    &#34;&#34;&#34; Class Play &#34;&#34;&#34;

    def __init__(self, path):
        &#34;&#34;&#34;
            Creates an object from a TEI-encoded theater play.

            Various information are also stored in the object,
            such as the title of the play, the author,
            the first publication date, etc.

            The object makes it easy to access characters of
            the play and their respective speeches.

            Args:
                path (str): Path to the xml file
            Returns:
                None

        &#34;&#34;&#34;

        # Declaring attributes needed to describe the play
        self.path = path
        self.speaker_speech = pd.DataFrame(columns=[&#39;speaker&#39;, &#39;speech&#39;, &#39;scene&#39;])
        self.title = &#39;?&#39;
        self.author = &#39;?&#39;
        self.date = &#39;?&#39;
        self.text = &#39;?&#39; # Raw, unstructured text, without speaker
        self.scenes = 0 # Amount of scenes in the play
        self.characters = [] # List of instanciated Character
        self.speech_amount = 0

        # Tries to open the file
        try:
            with open(self.path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as xml_file:
                xml_file = xml_file.read()

                # Removes all &lt;stage&gt; tags before processing
                xml_file = re.sub(r&#39;&lt;stage&gt;[^&lt;]+?&lt;/stage&gt;&#39;, &#39; &#39;, xml_file)

                # Makes a bs object
                soup = BeautifulSoup(xml_file, &#39;xml&#39;)

                # Gets the title of the play
                self.title = re.sub(r&#39;\s+&#39;, &#39; &#39;, soup.find(&#39;title&#39;).text)

                # Gets the author of the play
                self.author = soup.find(&#39;author&#39;).text

                # Gets the date of publication
                self.date = soup.find(&#39;imprint&#39;).find(&#39;date&#39;).text

                # Finds all the scenes (if any)
                scenes = soup.find_all(&#34;div&#34;, attrs={&#34;type&#34; : &#34;scene&#34;})

                # Finds all acts (if no scene has been found)
                if len(scenes) &lt; 1:
                    scenes = soup.find_all(&#34;div&#34;, attrs={&#34;type&#34; : &#34;act&#34;})

                # Finds body if no scene or act are found
                if len(scenes) &lt; 1:
                    scenes = soup.find_all(&#34;body&#34;)

                # To store speech id
                speech_id = 1

                # Loops through each scene
                for s in scenes:
                    # Increments the number of scenes
                    self.scenes += 1

                    # Finds all &#34;sp&#34; tags in current scene
                    tags_sp = s.find_all(&#39;sp&#39;)

                    # Gets scene number (if available)
                    try:
                        scene_number = int(s[&#34;n&#34;])
                    except:
                        scene_number = 1

                    # Loops through each sp
                    for _, sp in enumerate(tags_sp):
                        # Finding speaker
                        speaker = sp.find(&#39;speaker&#39;).text

                        # Skipping speakers that have long names
                        # because it happens that the speech gets confused
                        # with the speaker&#39;s name during encoding
                        if len(speaker) &gt; 35 or speaker.count(&#39; &#39;) &gt; 5:
                            continue

                        # Finds all other possible speech that
                        # a speaker can have (tags p and l)
                        tags = sp.find_all(&#39;p&#39;) + sp.find_all(&#39;l&#39;)

                        # Loops through all tags and adds to dataframe
                        for tag in tags:
                            tag = tag.text.strip()

                            # Stores in dataframe for easy retrieval
                            self.speaker_speech = pd.concat([
                                self.speaker_speech, self.speaker_speech.from_dict({
                                    &#39;speaker&#39;:[speaker],
                                    &#39;speech&#39;:[
                                        speech.Speech(
                                            tag,
                                            scene_number,
                                            speech_id)
                                        ],
                                    &#39;scene&#39;:[scene_number]
                                })
                            ], ignore_index=True)

                            # Adds raw text
                            self.text += &#39; &#39; + tag

                            # Increments speech count
                            speech_id += 1

            self.speech_amount = speech_id

            # Once it&#39;s done, creates all Character&#39;s instance
            self.makeCharacters()

            # Success message
            print(f&#39;&#39;&#39;# Play &#34;{self.title}&#34; ({self.author}, {self.date}) with {self.scenes} scene(s), {len(self.characters)} character(s) and {self.speech_amount} speech(es) successfully loaded!&#39;&#39;&#39;)

        # Returns empty dataframe if the file could not be opened/found
        except IOError:
            print(&#39;# Note : The supplied file was not found. Skipping process.&#39;)

    def makeCharacters(self):
        &#34;&#34;&#34; Creates a list of Characters to handle speeches easily.
            Returns a list of Character instances.
            Args:
                None

            Returns:
                None

            Examples:
                &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
                &gt;&gt;&gt; play.makeCharacters()
                &gt;&gt;&gt; play.characters
                [&lt;character.Character instance at 0x000001E5F1B0F048&gt;, &lt;character.Character instance at 0x000001E5F1B0F0C8&gt;, ...]


            &#34;&#34;&#34;

        # Gets a list of unique names for the characters
        characters = self.speaker_speech.speaker.unique()

        # Loops through each name and adds speech to character object
        for char in characters:
            speeches_df   = self.speaker_speech[self.speaker_speech.speaker == char]
            speeches_list = []

            # Skips names appearing once (mistakes while encoding the XML)
            if len(speeches_df) &lt; 2:
                continue

            # Adds each speech object to a temporary list
            for _, row in speeches_df.iterrows():
                speeches_list.append(row.speech)

            # Creates Character instance and links speeches to it
            newCharacter = character.Character(char)
            newCharacter.speeches = speeches_list

            # Stores Character instance in self.characters (list)
            self.characters.append(newCharacter)

    def getCharacters(self):
        &#34;&#34;&#34; Displays all characters in the play.
            Returns a list of characters.
            Args:
                None
            Returns: list
                A list of characters.
            Examples:
                &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
                &gt;&gt;&gt; play.getCharacters()
                [&#39;HAMLET&#39;, &#39;KING CLAUDIUS&#39;, &#39;QUEEN GERTRUDE&#39;, ...]


        &#34;&#34;&#34;

        # Loops through each character and find their name
        character_names = [character.name for character in self.characters]
        character_names.sort()

        return character_names

    @property
    def speechAmount(self):
        &#34;&#34;&#34; Displays the amount of speech in the whole play. &#34;&#34;&#34;

        return len(self.speaker_speech)

    @property
    def countWords(self):
        &#34;&#34;&#34; Displays the length of the play in words.
            Returns the amount of words in the play.&#34;&#34;&#34;

        words = 0

        # Loops through each character
        for char in self.characters:
            # Loops through each speech
            for speech in char.speeches:
                # Increment counter
                words += speech.countWords

        return words

    def to_csv(self):
        &#34;&#34;&#34; Exports a play to a CSV file.
            Returns a dataframe.
            Args:
                None
            Returns: dataframe
                A dataframe containing all the speeches in the play.
            Examples:
                &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
                &gt;&gt;&gt; play.to_csv()
                &gt;&gt;&gt; play.to_csv(&#39;path/to/file.csv&#39;)
                &gt;&gt;&gt; play.to_csv(&#39;path/to/file.csv&#39;, index=False)


                &#34;&#34;&#34;
    
        # Constructs dataframe
        export_df = pd.DataFrame(columns=[
            &#39;id&#39;,
            &#39;speaker&#39;,
            &#39;disambiguation_time&#39;,
            &#39;pywsd_output&#39;,
            &#39;tokens_text&#39;,
            &#39;tokens_emotions&#39;,
            &#39;scene&#39;,
            &#39;primary_emotion&#39;,
            &#39;secondary_emotion&#39;,
            &#39;text_disambiguate&#39;,
            &#39;speech&#39;
        ])

        # Loops through each character
        for c in self.characters:
            # Loops through each speech
            for s in c.speeches:
                export_df = pd.concat([export_df,export_df.from_dict({
                    &#39;id&#39;:[s.id],
                    &#39;speaker&#39;:[c.name],
                    &#39;disambiguation_time&#39;:[s.disambiguation_time],
                    &#39;pywsd_output&#39;:[s.pywsd_output],
                    &#39;tokens_text&#39;:[s.tokenized_text],
                    &#39;tokens_emotions&#39;:[s.tokenized_emotions],
                    &#39;scene&#39;:[s.scene],
                    &#39;primary_emotion&#39;:[s.primary_emotion],
                    &#39;secondary_emotion&#39;:[s.secondary_emotion],
                    &#39;text_disambiguate&#39;:[s.text_disambiguate],
                    &#39;speech&#39;:[s.text]
                })], ignore_index=True)

        # Saves csv to same folder than the script
        try:
            csv_name = self.title + &#39; - Exported.csv&#39;
            export_df.to_csv(csv_name, index=False)
            print(&#39;# Successfully exported to csv!&#39;)

        except IOError:
            print(&#39;# An error occured while exporting to csv!&#39;)

    def from_csv(self, path):
        &#34;&#34;&#34; Loads a play previously exported in a CSV file.
            Returns a dataframe.

            Args:
                path (str): Path to the CSV file.
            Returns:
                dataframe: Dataframe containing the play.
            Examples:
                &gt;&gt;&gt; play.from_csv(&#39;play.csv&#39;)



        &#34;&#34;&#34;

        try:
            # Loads CSV
            csv = pd.read_csv(path)

            # Empties dataframe
            self.speaker_speech = pd.DataFrame(columns=[&#39;speaker&#39;, &#39;speech&#39;, &#39;scene&#39;])
            self.characters = [] # List of instanciated Character

            # Finds all characters in the play and create object for each
            for row in csv.iterrows():
                # Stores variables used later
                text = row[1].speech
                scene = row[1].scene
                speech_id = row[1].id

                # Create new speech object
                s = speech.Speech(text, scene, speech_id)

                # Adds other properties to the object
                s.pywsd_output = row[1].pywsd_output
                s.tokenized_text = row[1].tokens_text
                s.tokenized_emotions = row[1].tokens_emotions
                s.primary_emotion = row[1].primary_emotion
                s.secondary_emotion = row[1].secondary_emotion
                s.text_disambiguate = row[1].text_disambiguate
                s.disambiguation_time = row[1].disambiguation_time

                # Adds to play dataframe
                speaker = row[1].speaker
                self.speaker_speech = pd.concat([self.speaker_speech,self.speaker_speech.from_dict({
                    &#39;speaker&#39;:[speaker],
                    &#39;speech&#39;:[s],
                    &#39;scene&#39;:[scene]
                })], ignore_index=True)

            # Sets max scene value
            self.scene = scene

            # Makes character
            self.makeCharacters()

            # Callback
            print(&#34;# Successfully loaded state from CSV file!&#34;)

        except TypeError:
            print(&#34;# The play state could not be loaded from CSV file!&#34;)

    def __str__(self):
        &#34;&#34;&#34; Returns the name of the play when printed. &#34;&#34;&#34;
        return self.title

    def __len__(self):
        &#34;&#34;&#34; Returns the amount of words in the play. &#34;&#34;&#34;
        return self.countWords</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="EmoPlay.play.Play"><code class="flex name class">
<span>class <span class="ident">Play</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Class Play </p>
<p>Creates an object from a TEI-encoded theater play.</p>
<p>Various information are also stored in the object,
such as the title of the play, the author,
the first publication date, etc.</p>
<p>The object makes it easy to access characters of
the play and their respective speeches.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the xml file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Play:
    &#34;&#34;&#34; Class Play &#34;&#34;&#34;

    def __init__(self, path):
        &#34;&#34;&#34;
            Creates an object from a TEI-encoded theater play.

            Various information are also stored in the object,
            such as the title of the play, the author,
            the first publication date, etc.

            The object makes it easy to access characters of
            the play and their respective speeches.

            Args:
                path (str): Path to the xml file
            Returns:
                None

        &#34;&#34;&#34;

        # Declaring attributes needed to describe the play
        self.path = path
        self.speaker_speech = pd.DataFrame(columns=[&#39;speaker&#39;, &#39;speech&#39;, &#39;scene&#39;])
        self.title = &#39;?&#39;
        self.author = &#39;?&#39;
        self.date = &#39;?&#39;
        self.text = &#39;?&#39; # Raw, unstructured text, without speaker
        self.scenes = 0 # Amount of scenes in the play
        self.characters = [] # List of instanciated Character
        self.speech_amount = 0

        # Tries to open the file
        try:
            with open(self.path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as xml_file:
                xml_file = xml_file.read()

                # Removes all &lt;stage&gt; tags before processing
                xml_file = re.sub(r&#39;&lt;stage&gt;[^&lt;]+?&lt;/stage&gt;&#39;, &#39; &#39;, xml_file)

                # Makes a bs object
                soup = BeautifulSoup(xml_file, &#39;xml&#39;)

                # Gets the title of the play
                self.title = re.sub(r&#39;\s+&#39;, &#39; &#39;, soup.find(&#39;title&#39;).text)

                # Gets the author of the play
                self.author = soup.find(&#39;author&#39;).text

                # Gets the date of publication
                self.date = soup.find(&#39;imprint&#39;).find(&#39;date&#39;).text

                # Finds all the scenes (if any)
                scenes = soup.find_all(&#34;div&#34;, attrs={&#34;type&#34; : &#34;scene&#34;})

                # Finds all acts (if no scene has been found)
                if len(scenes) &lt; 1:
                    scenes = soup.find_all(&#34;div&#34;, attrs={&#34;type&#34; : &#34;act&#34;})

                # Finds body if no scene or act are found
                if len(scenes) &lt; 1:
                    scenes = soup.find_all(&#34;body&#34;)

                # To store speech id
                speech_id = 1

                # Loops through each scene
                for s in scenes:
                    # Increments the number of scenes
                    self.scenes += 1

                    # Finds all &#34;sp&#34; tags in current scene
                    tags_sp = s.find_all(&#39;sp&#39;)

                    # Gets scene number (if available)
                    try:
                        scene_number = int(s[&#34;n&#34;])
                    except:
                        scene_number = 1

                    # Loops through each sp
                    for _, sp in enumerate(tags_sp):
                        # Finding speaker
                        speaker = sp.find(&#39;speaker&#39;).text

                        # Skipping speakers that have long names
                        # because it happens that the speech gets confused
                        # with the speaker&#39;s name during encoding
                        if len(speaker) &gt; 35 or speaker.count(&#39; &#39;) &gt; 5:
                            continue

                        # Finds all other possible speech that
                        # a speaker can have (tags p and l)
                        tags = sp.find_all(&#39;p&#39;) + sp.find_all(&#39;l&#39;)

                        # Loops through all tags and adds to dataframe
                        for tag in tags:
                            tag = tag.text.strip()

                            # Stores in dataframe for easy retrieval
                            self.speaker_speech = pd.concat([
                                self.speaker_speech, self.speaker_speech.from_dict({
                                    &#39;speaker&#39;:[speaker],
                                    &#39;speech&#39;:[
                                        speech.Speech(
                                            tag,
                                            scene_number,
                                            speech_id)
                                        ],
                                    &#39;scene&#39;:[scene_number]
                                })
                            ], ignore_index=True)

                            # Adds raw text
                            self.text += &#39; &#39; + tag

                            # Increments speech count
                            speech_id += 1

            self.speech_amount = speech_id

            # Once it&#39;s done, creates all Character&#39;s instance
            self.makeCharacters()

            # Success message
            print(f&#39;&#39;&#39;# Play &#34;{self.title}&#34; ({self.author}, {self.date}) with {self.scenes} scene(s), {len(self.characters)} character(s) and {self.speech_amount} speech(es) successfully loaded!&#39;&#39;&#39;)

        # Returns empty dataframe if the file could not be opened/found
        except IOError:
            print(&#39;# Note : The supplied file was not found. Skipping process.&#39;)

    def makeCharacters(self):
        &#34;&#34;&#34; Creates a list of Characters to handle speeches easily.
            Returns a list of Character instances.
            Args:
                None

            Returns:
                None

            Examples:
                &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
                &gt;&gt;&gt; play.makeCharacters()
                &gt;&gt;&gt; play.characters
                [&lt;character.Character instance at 0x000001E5F1B0F048&gt;, &lt;character.Character instance at 0x000001E5F1B0F0C8&gt;, ...]


            &#34;&#34;&#34;

        # Gets a list of unique names for the characters
        characters = self.speaker_speech.speaker.unique()

        # Loops through each name and adds speech to character object
        for char in characters:
            speeches_df   = self.speaker_speech[self.speaker_speech.speaker == char]
            speeches_list = []

            # Skips names appearing once (mistakes while encoding the XML)
            if len(speeches_df) &lt; 2:
                continue

            # Adds each speech object to a temporary list
            for _, row in speeches_df.iterrows():
                speeches_list.append(row.speech)

            # Creates Character instance and links speeches to it
            newCharacter = character.Character(char)
            newCharacter.speeches = speeches_list

            # Stores Character instance in self.characters (list)
            self.characters.append(newCharacter)

    def getCharacters(self):
        &#34;&#34;&#34; Displays all characters in the play.
            Returns a list of characters.
            Args:
                None
            Returns: list
                A list of characters.
            Examples:
                &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
                &gt;&gt;&gt; play.getCharacters()
                [&#39;HAMLET&#39;, &#39;KING CLAUDIUS&#39;, &#39;QUEEN GERTRUDE&#39;, ...]


        &#34;&#34;&#34;

        # Loops through each character and find their name
        character_names = [character.name for character in self.characters]
        character_names.sort()

        return character_names

    @property
    def speechAmount(self):
        &#34;&#34;&#34; Displays the amount of speech in the whole play. &#34;&#34;&#34;

        return len(self.speaker_speech)

    @property
    def countWords(self):
        &#34;&#34;&#34; Displays the length of the play in words.
            Returns the amount of words in the play.&#34;&#34;&#34;

        words = 0

        # Loops through each character
        for char in self.characters:
            # Loops through each speech
            for speech in char.speeches:
                # Increment counter
                words += speech.countWords

        return words

    def to_csv(self):
        &#34;&#34;&#34; Exports a play to a CSV file.
            Returns a dataframe.
            Args:
                None
            Returns: dataframe
                A dataframe containing all the speeches in the play.
            Examples:
                &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
                &gt;&gt;&gt; play.to_csv()
                &gt;&gt;&gt; play.to_csv(&#39;path/to/file.csv&#39;)
                &gt;&gt;&gt; play.to_csv(&#39;path/to/file.csv&#39;, index=False)


                &#34;&#34;&#34;
    
        # Constructs dataframe
        export_df = pd.DataFrame(columns=[
            &#39;id&#39;,
            &#39;speaker&#39;,
            &#39;disambiguation_time&#39;,
            &#39;pywsd_output&#39;,
            &#39;tokens_text&#39;,
            &#39;tokens_emotions&#39;,
            &#39;scene&#39;,
            &#39;primary_emotion&#39;,
            &#39;secondary_emotion&#39;,
            &#39;text_disambiguate&#39;,
            &#39;speech&#39;
        ])

        # Loops through each character
        for c in self.characters:
            # Loops through each speech
            for s in c.speeches:
                export_df = pd.concat([export_df,export_df.from_dict({
                    &#39;id&#39;:[s.id],
                    &#39;speaker&#39;:[c.name],
                    &#39;disambiguation_time&#39;:[s.disambiguation_time],
                    &#39;pywsd_output&#39;:[s.pywsd_output],
                    &#39;tokens_text&#39;:[s.tokenized_text],
                    &#39;tokens_emotions&#39;:[s.tokenized_emotions],
                    &#39;scene&#39;:[s.scene],
                    &#39;primary_emotion&#39;:[s.primary_emotion],
                    &#39;secondary_emotion&#39;:[s.secondary_emotion],
                    &#39;text_disambiguate&#39;:[s.text_disambiguate],
                    &#39;speech&#39;:[s.text]
                })], ignore_index=True)

        # Saves csv to same folder than the script
        try:
            csv_name = self.title + &#39; - Exported.csv&#39;
            export_df.to_csv(csv_name, index=False)
            print(&#39;# Successfully exported to csv!&#39;)

        except IOError:
            print(&#39;# An error occured while exporting to csv!&#39;)

    def from_csv(self, path):
        &#34;&#34;&#34; Loads a play previously exported in a CSV file.
            Returns a dataframe.

            Args:
                path (str): Path to the CSV file.
            Returns:
                dataframe: Dataframe containing the play.
            Examples:
                &gt;&gt;&gt; play.from_csv(&#39;play.csv&#39;)



        &#34;&#34;&#34;

        try:
            # Loads CSV
            csv = pd.read_csv(path)

            # Empties dataframe
            self.speaker_speech = pd.DataFrame(columns=[&#39;speaker&#39;, &#39;speech&#39;, &#39;scene&#39;])
            self.characters = [] # List of instanciated Character

            # Finds all characters in the play and create object for each
            for row in csv.iterrows():
                # Stores variables used later
                text = row[1].speech
                scene = row[1].scene
                speech_id = row[1].id

                # Create new speech object
                s = speech.Speech(text, scene, speech_id)

                # Adds other properties to the object
                s.pywsd_output = row[1].pywsd_output
                s.tokenized_text = row[1].tokens_text
                s.tokenized_emotions = row[1].tokens_emotions
                s.primary_emotion = row[1].primary_emotion
                s.secondary_emotion = row[1].secondary_emotion
                s.text_disambiguate = row[1].text_disambiguate
                s.disambiguation_time = row[1].disambiguation_time

                # Adds to play dataframe
                speaker = row[1].speaker
                self.speaker_speech = pd.concat([self.speaker_speech,self.speaker_speech.from_dict({
                    &#39;speaker&#39;:[speaker],
                    &#39;speech&#39;:[s],
                    &#39;scene&#39;:[scene]
                })], ignore_index=True)

            # Sets max scene value
            self.scene = scene

            # Makes character
            self.makeCharacters()

            # Callback
            print(&#34;# Successfully loaded state from CSV file!&#34;)

        except TypeError:
            print(&#34;# The play state could not be loaded from CSV file!&#34;)

    def __str__(self):
        &#34;&#34;&#34; Returns the name of the play when printed. &#34;&#34;&#34;
        return self.title

    def __len__(self):
        &#34;&#34;&#34; Returns the amount of words in the play. &#34;&#34;&#34;
        return self.countWords</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="EmoPlay.play.Play.countWords"><code class="name">var <span class="ident">countWords</span></code></dt>
<dd>
<div class="desc"><p>Displays the length of the play in words.
Returns the amount of words in the play.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def countWords(self):
    &#34;&#34;&#34; Displays the length of the play in words.
        Returns the amount of words in the play.&#34;&#34;&#34;

    words = 0

    # Loops through each character
    for char in self.characters:
        # Loops through each speech
        for speech in char.speeches:
            # Increment counter
            words += speech.countWords

    return words</code></pre>
</details>
</dd>
<dt id="EmoPlay.play.Play.speechAmount"><code class="name">var <span class="ident">speechAmount</span></code></dt>
<dd>
<div class="desc"><p>Displays the amount of speech in the whole play.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def speechAmount(self):
    &#34;&#34;&#34; Displays the amount of speech in the whole play. &#34;&#34;&#34;

    return len(self.speaker_speech)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="EmoPlay.play.Play.from_csv"><code class="name flex">
<span>def <span class="ident">from_csv</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads a play previously exported in a CSV file.
Returns a dataframe.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>Path to the CSV file.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dataframe</code></dt>
<dd>Dataframe containing the play.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; play.from_csv('play.csv')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_csv(self, path):
    &#34;&#34;&#34; Loads a play previously exported in a CSV file.
        Returns a dataframe.

        Args:
            path (str): Path to the CSV file.
        Returns:
            dataframe: Dataframe containing the play.
        Examples:
            &gt;&gt;&gt; play.from_csv(&#39;play.csv&#39;)



    &#34;&#34;&#34;

    try:
        # Loads CSV
        csv = pd.read_csv(path)

        # Empties dataframe
        self.speaker_speech = pd.DataFrame(columns=[&#39;speaker&#39;, &#39;speech&#39;, &#39;scene&#39;])
        self.characters = [] # List of instanciated Character

        # Finds all characters in the play and create object for each
        for row in csv.iterrows():
            # Stores variables used later
            text = row[1].speech
            scene = row[1].scene
            speech_id = row[1].id

            # Create new speech object
            s = speech.Speech(text, scene, speech_id)

            # Adds other properties to the object
            s.pywsd_output = row[1].pywsd_output
            s.tokenized_text = row[1].tokens_text
            s.tokenized_emotions = row[1].tokens_emotions
            s.primary_emotion = row[1].primary_emotion
            s.secondary_emotion = row[1].secondary_emotion
            s.text_disambiguate = row[1].text_disambiguate
            s.disambiguation_time = row[1].disambiguation_time

            # Adds to play dataframe
            speaker = row[1].speaker
            self.speaker_speech = pd.concat([self.speaker_speech,self.speaker_speech.from_dict({
                &#39;speaker&#39;:[speaker],
                &#39;speech&#39;:[s],
                &#39;scene&#39;:[scene]
            })], ignore_index=True)

        # Sets max scene value
        self.scene = scene

        # Makes character
        self.makeCharacters()

        # Callback
        print(&#34;# Successfully loaded state from CSV file!&#34;)

    except TypeError:
        print(&#34;# The play state could not be loaded from CSV file!&#34;)</code></pre>
</details>
</dd>
<dt id="EmoPlay.play.Play.getCharacters"><code class="name flex">
<span>def <span class="ident">getCharacters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Displays all characters in the play.
Returns a list of characters.</p>
<h2 id="args">Args</h2>
<p>None
Returns: list
A list of characters.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; play = Play('path/to/file.xml')
&gt;&gt;&gt; play.getCharacters()
['HAMLET', 'KING CLAUDIUS', 'QUEEN GERTRUDE', ...]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getCharacters(self):
    &#34;&#34;&#34; Displays all characters in the play.
        Returns a list of characters.
        Args:
            None
        Returns: list
            A list of characters.
        Examples:
            &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
            &gt;&gt;&gt; play.getCharacters()
            [&#39;HAMLET&#39;, &#39;KING CLAUDIUS&#39;, &#39;QUEEN GERTRUDE&#39;, ...]


    &#34;&#34;&#34;

    # Loops through each character and find their name
    character_names = [character.name for character in self.characters]
    character_names.sort()

    return character_names</code></pre>
</details>
</dd>
<dt id="EmoPlay.play.Play.makeCharacters"><code class="name flex">
<span>def <span class="ident">makeCharacters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a list of Characters to handle speeches easily.
Returns a list of Character instances.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; play = Play('path/to/file.xml')
&gt;&gt;&gt; play.makeCharacters()
&gt;&gt;&gt; play.characters
[&lt;character.Character instance at 0x000001E5F1B0F048&gt;, &lt;character.Character instance at 0x000001E5F1B0F0C8&gt;, ...]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeCharacters(self):
    &#34;&#34;&#34; Creates a list of Characters to handle speeches easily.
        Returns a list of Character instances.
        Args:
            None

        Returns:
            None

        Examples:
            &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
            &gt;&gt;&gt; play.makeCharacters()
            &gt;&gt;&gt; play.characters
            [&lt;character.Character instance at 0x000001E5F1B0F048&gt;, &lt;character.Character instance at 0x000001E5F1B0F0C8&gt;, ...]


        &#34;&#34;&#34;

    # Gets a list of unique names for the characters
    characters = self.speaker_speech.speaker.unique()

    # Loops through each name and adds speech to character object
    for char in characters:
        speeches_df   = self.speaker_speech[self.speaker_speech.speaker == char]
        speeches_list = []

        # Skips names appearing once (mistakes while encoding the XML)
        if len(speeches_df) &lt; 2:
            continue

        # Adds each speech object to a temporary list
        for _, row in speeches_df.iterrows():
            speeches_list.append(row.speech)

        # Creates Character instance and links speeches to it
        newCharacter = character.Character(char)
        newCharacter.speeches = speeches_list

        # Stores Character instance in self.characters (list)
        self.characters.append(newCharacter)</code></pre>
</details>
</dd>
<dt id="EmoPlay.play.Play.to_csv"><code class="name flex">
<span>def <span class="ident">to_csv</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Exports a play to a CSV file.
Returns a dataframe.</p>
<h2 id="args">Args</h2>
<p>None
Returns: dataframe
A dataframe containing all the speeches in the play.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; play = Play('path/to/file.xml')
&gt;&gt;&gt; play.to_csv()
&gt;&gt;&gt; play.to_csv('path/to/file.csv')
&gt;&gt;&gt; play.to_csv('path/to/file.csv', index=False)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_csv(self):
    &#34;&#34;&#34; Exports a play to a CSV file.
        Returns a dataframe.
        Args:
            None
        Returns: dataframe
            A dataframe containing all the speeches in the play.
        Examples:
            &gt;&gt;&gt; play = Play(&#39;path/to/file.xml&#39;)
            &gt;&gt;&gt; play.to_csv()
            &gt;&gt;&gt; play.to_csv(&#39;path/to/file.csv&#39;)
            &gt;&gt;&gt; play.to_csv(&#39;path/to/file.csv&#39;, index=False)


            &#34;&#34;&#34;

    # Constructs dataframe
    export_df = pd.DataFrame(columns=[
        &#39;id&#39;,
        &#39;speaker&#39;,
        &#39;disambiguation_time&#39;,
        &#39;pywsd_output&#39;,
        &#39;tokens_text&#39;,
        &#39;tokens_emotions&#39;,
        &#39;scene&#39;,
        &#39;primary_emotion&#39;,
        &#39;secondary_emotion&#39;,
        &#39;text_disambiguate&#39;,
        &#39;speech&#39;
    ])

    # Loops through each character
    for c in self.characters:
        # Loops through each speech
        for s in c.speeches:
            export_df = pd.concat([export_df,export_df.from_dict({
                &#39;id&#39;:[s.id],
                &#39;speaker&#39;:[c.name],
                &#39;disambiguation_time&#39;:[s.disambiguation_time],
                &#39;pywsd_output&#39;:[s.pywsd_output],
                &#39;tokens_text&#39;:[s.tokenized_text],
                &#39;tokens_emotions&#39;:[s.tokenized_emotions],
                &#39;scene&#39;:[s.scene],
                &#39;primary_emotion&#39;:[s.primary_emotion],
                &#39;secondary_emotion&#39;:[s.secondary_emotion],
                &#39;text_disambiguate&#39;:[s.text_disambiguate],
                &#39;speech&#39;:[s.text]
            })], ignore_index=True)

    # Saves csv to same folder than the script
    try:
        csv_name = self.title + &#39; - Exported.csv&#39;
        export_df.to_csv(csv_name, index=False)
        print(&#39;# Successfully exported to csv!&#39;)

    except IOError:
        print(&#39;# An error occured while exporting to csv!&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="EmoPlay" href="index.html">EmoPlay</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="EmoPlay.play.Play" href="#EmoPlay.play.Play">Play</a></code></h4>
<ul class="two-column">
<li><code><a title="EmoPlay.play.Play.countWords" href="#EmoPlay.play.Play.countWords">countWords</a></code></li>
<li><code><a title="EmoPlay.play.Play.from_csv" href="#EmoPlay.play.Play.from_csv">from_csv</a></code></li>
<li><code><a title="EmoPlay.play.Play.getCharacters" href="#EmoPlay.play.Play.getCharacters">getCharacters</a></code></li>
<li><code><a title="EmoPlay.play.Play.makeCharacters" href="#EmoPlay.play.Play.makeCharacters">makeCharacters</a></code></li>
<li><code><a title="EmoPlay.play.Play.speechAmount" href="#EmoPlay.play.Play.speechAmount">speechAmount</a></code></li>
<li><code><a title="EmoPlay.play.Play.to_csv" href="#EmoPlay.play.Play.to_csv">to_csv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>